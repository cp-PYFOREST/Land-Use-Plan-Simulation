```{r}
library(sf)
library(tidyverse)
library(here)
library(units)
library(knitr)
library(tictoc)
library(flextable)
```



```{r}
#source(knitr::purl(here("src", "boundary_registry_data.qmd")))
source(knitr::purl(here('src', "lup_simulator.qmd")))

```


```{r}
limit_lu <- st_read('/Users/romero61/../../capstone/pyforest/data/mock_properties/mock_properties.shp')

limit_lu <- limit_lu[19,]

hydro <- st_read('/Users/romero61/../../capstone/pyforest/data/river_buffer/river_buffer.gpkg')

```


```{r}
generate_statistics <-
  function(property_boundary,
           width_paddock,
           height_paddock,
           forest_reserve,
           paddocks,
           final_hedgerow,
           riparian_area,
           riparian_area_per) {
    statistics <- tibble(
      cat = property_boundary$cat,
      ratio_xy = paste(width_paddock, "/", height_paddock),
      property_area = st_area(property_boundary) |> drop_units(),
      property_units = "m^2",
      
      fr_area = sum(st_area(forest_reserve)) |> drop_units(),
      fr_units = "m^2",
      fr_per = round((sum((st_area(forest_reserve)) / st_area(property_boundary))) * 100,2) |> drop_units(),
      
      paddocks_area = round(sum(st_area(paddocks)),2) |> drop_units(),
      paddocks_units = "m^2",
      paddocks_per = round(sum(st_area(paddocks)) / st_area(property_boundary)* 100 ,2) |>  drop_units(),
      
      hedgerow_area = ifelse(is.null(final_hedgerow), NA, st_area(final_hedgerow)),
      
      hedgerow_per =  round((sum(st_area(final_hedgerow)) / st_area(property_boundary)) * 100,2) |> drop_units(),
    riparian_area =  ifelse(is.null(riparian_area), NA, st_area(riparian_area)) ,
    riparian_units = 'm^2',
    riparian_per =  ifelse(is.null(riparian_area), NA, st_area(riparian_area))
    )
    
    return(statistics)
  }
```


```{r}

tic()
  # create a vector of unique combinations of width_paddock and height_paddock
paddock_dims <- expand_grid(width_paddock = 1:4, height_paddock = 1:4) |>
  subset(width_paddock != height_paddock | width_paddock == 1)

# create an empty data frame to store the results
results_df <- data.frame()

#  loop through each property ID
for (i in seq_along(limit_lu$cat)) {


 # loop through each row of the paddock_dims data frame and perform the analysis
  for (j in seq_along(paddock_dims$width_paddock)){
    tryCatch({
    tic()
    w = paddock_dims$width_paddock[j]
    h= paddock_dims$height_paddock[j]
    width_paddock = paddock_dims$width_paddock[j]
    height_paddock = paddock_dims$height_paddock[j]
    
    
    property_id <- as.integer(limit_lu$cat[i])
    print(paste('current iteration:', i,j, 'ratio',w,'/',h))
  # Select Property
  property_boundary <- select_property(property_id)
  
  # Riparian Corridor check
  riparian_corridor <- riparian_buffer(property_boundary)
  

  
  pad_hedg_dim <- property_dimensions(
    desired_area = 999999,
    hedgerow_width = 100,
    width_paddock = paddock_dims$width_paddock[j],
    height_paddock = paddock_dims$height_paddock[j])
  
  # Create Grid , Rotate, Cut With Property
  print("Creating grid, rotating, and cutting with property")
  property_grid <- grid_rotate(property_boundary, pad_hedg_dim)
  
  # Cut Grid w/ River
  print("Cutting grid with river")
  property_fragment <- riparian_cut(riparian_corridor, property_grid)

  # Create Forest Reserve â‰¥ 25% 
  print("Calculating forest reserve")
  forest_reserve <- reserve(property_fragment,property_boundary)
  
  # Property w/o reserve area
  # 
  print("Calculating remaining area without forest reserve")
  property_remaining <- no_reserve_area(grid_property = property_fragment,
                  fr_union = forest_reserve)

  # Hedgerows
  print("Dividing area into paddocks and hedgerows")
  hedgerows <- make_hedges(property_remaining)
  
  hedge <- st_erase(hedgerows, property_boundary)
  hedges <- st_difference(hedgerows, hedge)
  cut_reserve <- st_intersection(forest_reserve, hedges)
  hedges <- st_difference(hedges, cut_reserve) |> st_simplify(dTolerance = 10)
    
  print("After processing hedgerows")
  
  # Paddocks
  paddocks <- make_paddocks(property_remaining, hedgerows)
 
  
  print("After processing paddocks")
  # If there is a corridor cut edges
  if(is.null(riparian_corridor) == FALSE) {
    riparian_area <- round(st_area(riparian_corridor),2)
    riparian_area_per <-
      (st_area(riparian_corridor) / st_area(property_boundary)) * 100
     final_hedgerow <- st_difference(hedges, riparian_corridor) |> st_sf() |>
   st_collection_extract(type = 'POLYGON')
    
  } else{
    riparian_area <- NULL
    riparian_area_per <- NULL
    final_hedgerow <- hedgerows
  }
  
  
  
   print("Calculating final statistics")
  
  # Final Areas
   statistics <-
     generate_statistics(
       property_boundary,
       width_paddock,
       height_paddock,
       forest_reserve,
       paddocks,
       final_hedgerow,
       riparian_corridor
     )

  print(paste('stats:',nrow(statistics)))
  print("Done with process_property function")
  results_df <- bind_rows(results_df,statistics)
  toc()

  },
  
   error = function(e) {
     error_tibble <- tibble(
       cat = paste(property_id,w, h),
       error = as.character(e)
     )
   results_df <- bind_rows(results_df, error_tibble)
   })
  print("After tryCatch block")
  print(paste("Returning result for property_id:", property_id, ", width_paddock:", w, ", height_paddock:", h))
  }
}
# save the final dataframe
#saveRDS(results_df, "/Users/romero61/../../capstone/pyforest/data/results_df/results.rds")
toc()
```

```{r}
test <-  generate_statistics(
       property_boundary,
       width_paddock,
       height_paddock,
       forest_reserve,
       paddocks,
       final_hedgerow,
       riparian_corridor
     )
```



```{r}
theme_vader(flextable(results_df))
#results_df280 <- saveRDS(results_df, '~/../../capstone/pyforest/data/results_df/results280.rds')

```


```{r}
percentages <- results_df |>
  select(-error_paddocks, -error_hedgerow, -corridor_area, -property_area, -property_units, -fr_area, -paddocks_area, -paddocks_units, - hedgerow_area, -fr_units) |>
  drop_units() |> 
  replace_na(replace = list(corridor_per = 0)) |> mutate(sum_percentage = fr_per + paddocks_per + hedgerow_per + corridor_per)
#saveRDS(statistics, "/Users/romero61/../../capstone/pyforest/data/results_df/statistics.rds")
theme_apa(flextable(percentages))
```

```{r}
plot(hedgerows)
plot(hedge)
plot(hedges)
plot(cut_reserve)
plot(final_hedgerow2)
plot(riparian_corridor)

# final_hedgerow2 <- final_hedgerow |>
#   st_as_sf() |>
#   st_cast(to = 'POLYGON')
# st_write(hedgerows,'/Users/romero61/../../capstone/pyforest/data/property_4739/hedgerows.shp')
# st_write(hedge,'/Users/romero61/../../capstone/pyforest/data/property_4739/hedge.shp')
# st_write(hedges,'/Users/romero61/../../capstone/pyforest/data/property_4739/hedges.shp')
# st_write(cut_reserve,'/Users/romero61/../../capstone/pyforest/data/property_4739/cut_reserve.shp')
# st_write(final_hedgerow2,'/Users/romero61/../../capstone/pyforest/data/property_4739/final_hedgerow2.shp')
# st_write(riparian_corridor,'/Users/romero61/../../capstone/pyforest/data/property_4739/riparian_corridor.shp')
# st_write(paddocks,'/Users/romero61/../../capstone/pyforest/data/property_4739/paddocks.shp')
# st_write(property_boundary,'/Users/romero61/../../capstone/pyforest/data/property_4739/property_boundary.shp')
# st_write(property_fragment,'/Users/romero61/../../capstone/pyforest/data/property_4739/property_fragment.shp')
# st_write(property_grid,'/Users/romero61/../../capstone/pyforest/data/property_4739/property_grid.shp')
# st_write(property_remaining,'/Users/romero61/../../capstone/pyforest/data/property_4739/property_remaining.shp')

```




```{r}
#read_rds('areas_pads_999999.rds')
#read_rds('areas_pads_999.rds')
#read_rds('areas_pads_tol005.rds')
#paddocks_list <- read_rds('paddocks_df.rds')

#areas_pads
#paddocks_list$paddocks_list
#saveRDS(areas_pads_999999,"areas_pads_999999.rds")
```


